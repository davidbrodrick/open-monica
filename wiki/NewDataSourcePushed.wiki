#summary Guidelines for writing a new DataSource.

= Introduction =

Data sources bring new data into the MoniCA system (see the IntroServerCode for a brief introduction to the architecture). This document discusses a few of the key ideas and outlines some strategies applicable to common monitoring tasks.

Many data sources will communicate with the device that provides data via a socket, however that is not a requirement imposed by the software, data sources may execute system programs, read from files, or do whatever else is required for them to obtain the relevant data.

The 'standard' MoniCA data source model is that MoniCAs scheduler determines 

The `DataSource` class interface includes methods to enable rapid development of subclasses which use the 'standard' MoniCA model, however many variations could be implemented. They key requirement of a data source is that it provides value updates for one or more monitor points.

= Updating monitor points. =

{{{
PointMonitor pm = MonitorMap.getPointMonitor(itsNumBeerPointName);
PointData pd = new PointData(itsNumBeerPointName, numbeers);
pm.firePointEvent(new PointEvent(this, pd, true));
}}}

== Connect/Disconnect ==

Each data source has methods to connect/disconnect from the remote end point. For the sake of brevity these are not shown here, however DataSourceASCII contains methods which are almost identical to our requirements if you'd like to take a look at that.

== getData ==

The `DataSource.getData()` method is called whenever MoniCA's internal update scheduler determines our monitor points are due for updating. Since the Blottometer has no mechanism for us to request an update, this method is redundant. This is the core difference in strategy between data sources which poll for updates vs data sources like ours which parse data that is pushed from the device.

Because it is not relevant, we can define an empty implementation of getData.
{{{
/** Dummy getData method. */
protected void getData(Object[] points)
{
}
}}}

== Internal Thread ==
