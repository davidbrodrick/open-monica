#summary High-level Introduction To MoniCA Code

= Introduction =

This page gives a very high level introduction to the different classes/packages in MoniCA to assist new developers get a quick feel for the basic architecture of the software. As MoniCA is client/server software these components are examined separately.

= Server =

The server maintains the database of all the current values available to the system and makes the data available to client programs. The server can also perform archiving of monitor point values and makes archival values available to clients on request.

== Data Sources ==

A data source (instance of a `DataSource` sub-class) is usually responsible for collecting data from one remote device/process. For instance you may have one data source which talks to your UPS and a different data source which communicates with your weather station. Each data source may update values for multiple monitor points corresponding to different parameters available from the UPS or weather station (for example).

Data sources can use at least two basic philosophies:
  * *Pulled:* The data source queries the remote device to obtain a new value for each monitor point whenever MoniCA's internal scheduler determines that the point is due for an update.
  * *Pushed:* The remote device may send unsolicited updates to the data source, so the data source only needs to parse the data and fire the new values off as updates to the relevant monitor points. The internal update scheduler is not used in this case.

Data sources may accept instantiation-time arguments defined in the `monitor-sources.txt` config file, for instance to tell it the network address of which UPS you wish to monitor. In this fashion, you may monitor many instances of one kind of device without needing to make any software changes to the data source.

== Monitor Points ==

Monitor points (`PointMonitor` instances) encapsulate all of the meta-data for a single parameter that the system is monitoring. This includes information such as the description of the monitor point, units, source name (eg the network address of which particular UPS this datum comes from), update interval, etc. Monitor points are defined in the `monitor-points.txt` config file or may be dynamically created by data sources (eg, after the data source automatically discovers what data is available from the device).

The monitor point object has fields for other objects related to this point, such as to tell the system under what conditions this point's values should be archived, or how to translate the raw value read from hardware into a meaningful value. Some of these classes are explored below.

=== Transactions ===

When a monitor point is scheduled to be updated, it is handed to the appropriate data source so that a new value can be obtained. The point's `Transaction` field has two roles to play in this process:

  * The transaction `channel` name is combined with the monitor point's `source` to locate the data source responsible for updating this point.
  * If the data source requires additional information to obtain the new value for each point, eg an address of the hardware register where this point's value is located, then the transaction subclass can contain the additional fields required by the data source. These fields are populated by transaction arguments in the monitor point definitions file.

`TransactionListen` allows monitor points to receive updates whenever other specific points are updated, and is a useful tool in agregating points to create new information or higher-level constructs.

=== Translations ===

After the data source has collected a new value for the monitor point, we may wish to process it into a more meaninful form. For instace we might convert a raw number obtained from an ADC into a floating point voltage, or extract a single bit from an integer, or map an integer to a descriptive string, etc.

`Translation` subclasses can be used to perform these processing steps on new values. Each monitor point can have any number of translations organised as a chain, such that the output of one translation is used as input to the next. This way complex behaviour can be achieved at configuration-time rather than requiring new code. 

There are few limitations on what operations translations can perform, for instance some may perform statistical analyses on a history of N inputs. Others may aggregate the values from several monitor points to produce new kinds of data.

=== Value Checking ===

A monitor point can have an associated `PointLimit` object which determines whether the current value is okay, or in an alarm state. Essentially any logic may be used by a `PointLimit` subclass, common examples include checking whether a numeric value is inside a specified range, or checking a string value against a known set of alarm strings.

=== Archiving ===

Monitor points may have one or more `ArchivePolicy` objects which tell the `Archiver` whether the current value of a monitor point should be archived to disk or not. Common examples include archiving every Nth update, or archiving only when the value changes, however more sophisticated logic could be used such as checking the values of other monitor points to determine whether to archive this point or not.

== Configuration ==

= Client =

== Main Frame ==

== Mon Panels ==