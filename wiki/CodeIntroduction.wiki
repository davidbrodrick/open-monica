#summary High-level Introduction To MoniCA Code

= Introduction =

This page gives a very high level introduction to the different classes/packages in MoniCA to assist new developers get a quick feel for the basic architecture of the software. As MoniCA is client/server software these components are examined separately.

= Server =

The server maintains the database of all the current values available to the system and makes the data available to client programs. The server can also perform archiving of monitor point values and makes archival values available to clients on request.

== Data Sources ==

A data source (instance of a `DataSource` sub-class) is usually responsible for collecting data from one remote device/process. For instance you may have one data source which talks to your UPS and a different data source which communicates with your weather station. Each data source may update values for multiple monitor points corresponding to different parameters available from the UPS or weather station (for example).

Data sources can use at least two basic philosophies:
  * *Pulled:* The data source queries the remote device to obtain a new value for each monitor point whenever MoniCA's internal scheduler determines that the point is due for an update.
  * *Pushed:* The remote device may send unsolicited updates to the data source, so the data source only needs to parse the data and fire the new values off as updates to the relevant monitor points. The internal update scheduler is not used in this case.

Data sources may accept instantiation-time arguments defined in the `monitor-sources.txt` config file, for instance to tell it the network address of which UPS you wish to monitor. In this fashion, you may monitor many instances of one kind of device without needing to make any software changes to the data source.

== Monitor Points ==

Monitor points (`PointMonitor` instances) encapsulate all of the meta-data for a single parameter that the system is monitoring. This includes information such as the description of the monitor point, units, source name (eg the network address of which particular UPS this datum comes from), update interval, etc. Monitor points are defined in the `monitor-points.txt` config file or may be dynamically created by data sources (eg, after the data source automatically discovers what data is available from the device).

The monitor point object has fields for other objects related to this point, such as to tell the system under what conditions this point's values should be archived, or how to translate the raw value read from hardware into a meaningful value. Some of these classes are explored below.

=== Transactions ===

When a monitor point is scheduled to be updated, it is handed to the appropriate data source so that a new value can be obtained. The point's `Transaction` field has two roles to play in this process:

  * The transaction `channel` name is combined with the monitor point's `source` to locate the data source responsible for updating this point.
  * If the data source requires additional information to obtain the new value for each point, eg an address of the hardware register where this point's value is located, then the transaction subclass can contain the additional fields required by the data source. These fields are populated by transaction arguments in the monitor point definitions file.

`TransactionListen` allows monitor points to receive updates whenever other specific points are updated, and is a useful tool in agregating points to create new information or higher-level constructs.

=== Translations ===

One or more `Translation` subclasses can be used to process the raw value returned by the Data Source into a meaningful real-world value. It is a useful mechanism for dumb Data Sources which just return the raw numerical value of a hardware register. However it can also be very useful for many other purposes, such as calculating moving averages of a value, combining different values in sophisticated ways, etc.

*mention Enum*

=== Value Checking ===

A monitor point can have an associated `PointLimit` subclass which determines whether the current value is okay, or in an alarm state. There is essentially no limits on the logic that the check may use. Common examples include checking whether a numeric value is inside a specified range, or checking the values of a string against a known set.

=== Archiving ===

== Configuration ==

= Client =

== Main Frame ==

== Mon Panels ==